/**
任务描述：任意给定一个包含n个整数的集合，且n个整数已经按升序排列。任意
给定一个整数k，判断该整数是否在集合中。
输入：每个测试用例包括两行，第一行包含两个整数k和n，其中k表示待查找的
元素，n(n≤10000)表示集合中整数的个数，第二行输入n个整数，数与数之间用
空格隔开。最后一行包含-1，表示输入结束。
输出：每组测试数据的结果输出占一行，如果元素k存在数组中则输出其下标，
否则输出-1。
样例输入：
38 7
13 27 38 49 65 76 97
-1
样例输出：
2
**/
/**思路:
把集合? = {? ? , ? , ?[?]}分成个数大致相同的两部分： ?1 = {? ? , ? , ?[(? + ?)/2 ? 1]}
为第一部分， ?2 = {? (? + ?)/2 + 1 , ? , ?[?]}为第二部分
取? (? + ?)/2 与?做比较
如果? > ?[(? + ?)/2]，则在?2中查找，而?1可以减去不用再考虑；
如果? < ?[(? + ?)/2]，则在?1中查找，而?2可以舍弃；
如果? = ?[(? + ?)/2]，则已经找到目标元素，输出其下标。
**/
int BinarySearch(int Data[], int Len, int k)
{

    int Left = 0, Right = Len - 1, Mid = 0;
    while (Left <= Right)
    {
        Mid = (Left + Right) / 2;
        if (k == Data[Mid])
            return Mid;
        if (k < Data[Mid])
            Right = Mid - 1;
        else
    