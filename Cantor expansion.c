//康多展开
//康托展开的公式是 X=an*(n-1)!+an-1*(n-2)!+...+ai*(i-1)!+...+a2*1!+a1*0! 其中，ai为当前未出现的元素中是排在第几个（从0开始）。
//eg：对于序列： 52413 该序列展开后为： 4 * 4! + 1 * 3! + 2 * 2! + 0 * 1! + 0 * 0! ，计算结果是： 106
//eg: 12345的康托展开值，也就是：0*4！+ 0*3！+ 0*2！+ 0*1！+0*0！ =  0
//逆展开
//用 61 / 4! = 2余13，说明a[5]=2,说明比首位小的数有2个，所以首位为3。
//用 13 / 3! = 2余1，说明a[4]=2，说明在第二位之后小于第二位的数有2个，所以第二位为4。
//用 1 / 2! = 0余1，说明a[3]=0，说明在第三位之后没有小于第三位的数，所以第三位为1。
//用 1 / 1! = 1余0，说明a[2]=1，说明在第二位之后小于第四位的数有1个，所以第四位为5。
//最后一位自然就是剩下的数2啦。
//通过以上分析，所求排列组合为 34152。
#include <stdio.h>
#include <stdbool.h>
bool book[10] = {0}; //标记是否已经出现过
int fact[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
int cator(int *a, int n)
{
    int x = 0; //保存康托展开值
    for (int i = 0; i < n; i++)
    {
        int smaller = 0; //在当前位置后小于其的个数
        for (int j = i + 1; j < n; j++)
        {
            if (a[i] > a[j])
                smaller++;
        }
        printf("%d",smaller * fact[n - i - 1]);
        x += smaller * fact[n - i - 1];
    }
    return x;
}
void cator_n(int n, int N)
{
    int mid, i;
    for (i = n; i >= 1; i--)
    {
        mid = N / fact[i - 1] + 1; //做逆运算
        for (int i = 1; i <= mid; i++)
            if (book[i])
                mid++;

        book[mid] = true;
        printf("%d", mid);
        N %= fact[i - 1];
    }
}
int main()
{
    int a[5] = {5, 2, 4, 3, 1};
    printf("%d\n", cator(a, 5));
    cator_n(5, 61);
}